#!/usr/bin/perl

use strict;
use warnings;

use YAML::XS qw/LoadFile/;
use List::Util qw/max/;

my @cols = ();
my @widths = ();
sub column
{
	@_ = map { "$_," } @_;
	if (!@cols) {
		@widths = map { 0 } @_;
	} else {
		for (my $i = 0; $i < @_; $i++) {
			$widths[$i] = max($widths[$i], length $_[$i]);
		}
	}

	push @cols, [@_];
}

sub table
{
	my ($fmt) = @_;
	$fmt =~ s/%s/%-${_}s/ for @widths;
	printf $fmt, @$_ for @cols;
}

sub arg
{
	my ($list, $reg) = @_;
	return ("", "ARG_NONE") if !$list || !@$list;

	my (@names, @flags);
	for (@$list) {
		if (m/register/) {
			push @names, $reg;
			push @flags, "ARG_REGISTER";
		} elsif (m/(number|string|function|label)/) {
			push @names, "<$1>";
			push @flags, uc("ARG_$1");
		} else {
			die "Unhandled arg type $_\n";
		}
	}

	return ((@names == 1 ? " $names[0]" : " (".join('|', @names).")"), join('|', @flags));
}

my $lst = eval { LoadFile "opcodes.yml" }
	or die "Failed to load opcoes.yml: $!\n";

for my $op (@$lst) {
	my ($key, $o) = %$op;
	if (!$o->{constant}) {
		$o->{constant} = uc($key);
		$o->{constant} =~ s/\./_/g;
		$o->{constant} =~ s/\?$/_P/g;
	}

	$o->{opcode} = uc($o->{alias} || $o->{constant});

	my ($name, $flags);
	my $usage;

	$usage = $key;
	($name, $flags) = arg($o->{args}[0], "%a");
	$usage .= $name; $o->{args}[0] = $flags;

	($name, $flags) = arg($o->{args}[1], "%b");
	$usage .= $name; $o->{args}[1] = $flags;

	$o->{usage} = $usage if !$o->{usage};
}

my $n = 0;
my $len = 0;
for my $op (@$lst) {
	my ($key, $o) = %$op;
	$len = max($len, length($o->{constant}));
	$n++;
}

$n = 0;
print "/* opcodes.h - generated by gencode */\n\n";
print "/** OPCODE CONSTANTS **/\n";
for my $op (@$lst) {
	my ($key, $o) = %$op;
	next if $o->{alias};
	printf "#define %-${len}s  %#04x  /* %s */\n", $o->{constant}, $n++, $o->{help};
}

print "\n\n";
print "#ifdef OPCODES_EXTENDED\n";
print "/** OPCODE MNEMONIC NAMES **/\n";
print "static const char * OPCODES[] = {\n";
$n = 0;
for my $op (@$lst) {
	my ($key, $o) = %$op;
	next if $o->{alias};
	printf qq(\t%-@{[$len+3]}s /* %-${len}s  %2i  %#04x */\n), qq("$key",), $o->{constant}, $n, $n;
	$n++;
}
print "\tNULL,\n";
print "};\n";

print "\n\n";
print "/** ASM TOKENS **/\n";
$n = 0x40;
for my $op (@$lst) {
	my ($key, $o) = %$op;
	printf "#define T_OPCODE_%-${len}s  %#04x  /* %s */\n", $o->{constant}, $n++, $o->{help};
}

print "\n\n";
print "static const char * ASM[] = {\n";
$n = 0;
for my $op (@$lst) {
	my ($key, $o) = %$op;
	printf qq(\t%-@{[$len+3]}s /* T_OPCODE_%-${len}s  %2i  %#04x */\n), qq("$key",), $o->{constant}, $n, $n;
	$n++;
}
print "\tNULL,\n";
print "};\n\n";

print <<EOF;
#define ARG_NONE      0x00
#define ARG_REGISTER  0x01
#define ARG_NUMBER    0x02
#define ARG_STRING    0x04
#define ARG_LABEL     0x08
#define ARG_FUNCTION  0x10

static struct {
	byte_t      token;
	const char *usage;
	byte_t      opcode;
	byte_t      args[2];
} ASM_SYNTAX[] = {
EOF

for my $op (@$lst) {
	my ($key, $o) = %$op;
	column "T_OPCODE_$o->{constant}", qq("$o->{usage}"), $o->{opcode}, $o->{args}[0], $o->{args}[1];
}
table "\t{ %s %s %s { %s %s } },\n";
print "\t{ 0, 0, 0, { 0, 0 } },\n";
print "};\n\n";

print "#endif\n";
